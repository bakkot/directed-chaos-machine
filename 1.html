<html>
<head>
<style>
#overlay {
  display: none;
  background: none repeat scroll 0 0 #424242;
  z-index: 100;
  height: 100%;
  width: 100%;
  position: fixed;
  top: 0;
  left: 0;
  /*opacity: .8;*/
  background-color: rgba(0,0,0,0.5);
  pointer-events: none;
  
}

canvas {
  border-style: solid;
  border-width: 2px;
  border-color: #aaa;
}


#meta {
  width: 100%;
  display: inline-block;
}

#candiv {
  float: left;
  /*display: inline-block;*/
  width: 500px;
  min-height: 500px;
  padding-right: 10px;
  margin-right: 10px;
  border-right: 4px solid #777;
}

#textdiv {
  width: 90%;
  /*display: inline-block;*/
}

h2 {
  margin-top: 5px;
  margin-bottom: 0px;
}

#can-overlay {
  position: absolute;
  height: 504px;
  width: 504px;
  z-index: 10;
  pointer-events: none;
  overflow: hidden;
}

#spotlight {
  position: absolute;
  left: -20;
  right: -20;
  background-color:  rgba(255,255,255,0);
  border-radius: 500px;
  box-shadow: 0px 0px 0px 1000px rgba(0,0,0,0.5);
  height: 10px; /* remember to modify highlight() as well*/
  width: 10px;
}
</style>


<script src="numeric-1.2.6.js"></script> <!-- only used for solving a system of linear equations, 'cause I'm lazy --> 
<script src="dragster.js"></script> <!-- for dragging files to work as expected. also, wtf, this should not be necessary. --> 
<script>
var overlay, canvasOverlay, spotlight, canvas, ctx, imgScale, state, spaceHeld;
var inPoints = [];
var outPoints = [];
var transforms = [];
var MAXWIDTH = 490;

function relCoords(event, ele){
  var rect = ele.getBoundingClientRect();
  return {x: event.clientX - rect.left, y: event.clientY - rect.top};
}

function affineFactory(a, b, c, d, e, f) {
  return function(p) {
    return {x: a*p.x + b*p.y + e, y: c*p.x + d*p.y + f};
  }
}


/* logic:
Ax'   a b   Ax      e
Ay' = c d   Ay    + f


Ax' = aAx + bAy + e
Ay' = cAx + dAy + f

first computation solves for a, b, e, second for c, d, f.
*/
function makeTransform(inPoints, outPoints) {
  var A = [ [inPoints[0].x, inPoints[0].y, 1],
            [inPoints[1].x, inPoints[1].y, 1],
            [inPoints[2].x, inPoints[2].y, 1] ];
  var B1 = [ outPoints[0].x, outPoints[1].x, outPoints[2].x ];
  var B2 = [ outPoints[0].y, outPoints[1].y, outPoints[2].y ];
  
  var X1 = numeric.solve(A, B1);
  var X2 = numeric.solve(A, B2);
  
  return affineFactory(X1[0], X1[1], X2[0], X2[1], X1[2], X2[2]);
}

function transform(p) {
  var ind = Math.floor(Math.random() * transforms.length);
  return transforms[ind](p);
}





function drawPoint(p) {
  ctx.fillRect(p.x, p.y, 1, 1);
}


var SPEED = 20;
var SKIP = 100;
var DELAY = 1;
var point;
function draw() {
  if(typeof point == 'undefined') {
    point = {x: Math.random() * canvas.width, y: Math.random() * canvas.height};
    for(var i=0; i<SKIP; ++i) {
      var ind = Math.floor(Math.random() * transforms.length);
      point = transform(point);
    }
  }
  
  for(var i=0; i<SPEED; ++i) {
    point = transform(point);
    drawPoint(point);
  }
  
  if(!spaceHeld) return;
  
  setTimeout(draw, DELAY);
}







function dragEnter(e) {
  e.stopPropagation();
  e.preventDefault();
  
  overlay.style.display = 'block';
}

function dragOver(e) {
  e.stopPropagation();
  e.preventDefault();
}

function dragLeave(e) {
  overlay.style.display = 'none';
}

function drop(e) {
  e.stopPropagation();
  e.preventDefault();
  overlay.style.display = 'none';
  
  processFiles(e.dataTransfer.files);
}


function reset() {
  canvas.width = canvas.height = 500; // also resets
  canvasOverlay.style.width = canvas.width + 4;
  canvasOverlay.style.height = canvas.height + 4;
  state = 'I1';
  inPoints = [];
  outPoints = [];
  transforms = [];
}

function processFiles(files) {
  if(files.length != 1) { // todo errors
    return;
  }
  if (!files[0].type.match(/image.*/)) { // todo errors
    return;
  }

  // thanks http://stackoverflow.com/a/10209693/1644272
  // https://developer.mozilla.org/en-US/docs/Using_files_from_web_applications#Selecting_files_using_drag_and_drop
  var img = new Image();
  var src = URL.createObjectURL(files[0]);
  img.src = src;
  img.onload = function(){
    reset();
    imgScale = Math.min(img.width, MAXWIDTH) / img.width;
    canvas.width = img.width * imgScale + 10;
    canvas.height = img.height * imgScale + 10;
    canvasOverlay.style.width = canvas.width + 4;
    canvasOverlay.style.height = canvas.height + 4;
    console.log(canvasOverlay.width)
    ctx.globalAlpha = 0.2;
    ctx.drawImage(img, 5, 5, img.width * imgScale, img.height * imgScale);
    ctx.globalAlpha = 1;
    URL.revokeObjectURL(src);
  }
}


function highlight(p) {
  spotlight.style.left = p.x+2-10/2;
  spotlight.style.top = p.y+2-10/2;
}



function click(e) {
  var p = relCoords(e, canvas);
  highlight(p);
  advance(p);
}

function advance(p) {
  switch (state) {
    case 'I1':
      inPoints[0] = p;
      ctx.strokeStyle = 'rgb(200,0,0)';
      ctx.beginPath();
      ctx.arc(p.x,p.y,2,0,2*Math.PI);
      ctx.stroke();
      ctx.closePath();
      state = 'I2';
      break;
    case 'I2':
      inPoints[1] = p;
      ctx.strokeStyle = 'rgb(0,200,0)';
      ctx.beginPath();
      ctx.arc(p.x,p.y,2,0,2*Math.PI);
      ctx.stroke();
      ctx.closePath();
      state = 'I3';
      break;
    case 'I3':
      inPoints[2] = p;
      ctx.strokeStyle = 'rgb(0,0,200)';
      ctx.beginPath();
      ctx.arc(p.x,p.y,2,0,2*Math.PI);
      ctx.stroke();
      ctx.closePath();
      state = 'O1';
      break;
    case 'O1':
      outPoints[0] = p;
      ctx.strokeStyle = 'rgba(255,0,0,0.5)';
      ctx.beginPath();
      ctx.arc(p.x,p.y,1.5,0,2*Math.PI);
      ctx.stroke();
      ctx.closePath();
      state = 'O2';
      break;
    case 'O2':
      outPoints[1] = p;
      ctx.strokeStyle = 'rgba(0,255,0,0.5)';
      ctx.beginPath();
      ctx.arc(p.x,p.y,1.5,0,2*Math.PI);
      ctx.stroke();
      ctx.closePath();
      state = 'O3';
      break;
    case 'O3':
      outPoints[2] = p;
      ctx.strokeStyle = 'rgba(0,0,255,0.5)';
      ctx.beginPath();
      ctx.arc(p.x,p.y,1.5,0,2*Math.PI);
      ctx.stroke();
      ctx.closePath();
      transforms.push(makeTransform(inPoints, outPoints));
      outPoints = [];
      state = 'O1';
      break;
    case 'Done':
      break;
    default: 
      alert('wat');
  }
}

function keyDown(e) {
  console.log(e)
  switch (e.which) {
    case 32: // space
      spaceHeld = true;
      e.preventDefault();
      draw();
      break;
    case 82: // r
      reset()
      break;
    case 8: // backspace
      e.preventDefault();
      break;
  }
}

function keyUp(e) {
  if (e.which == 32) {
    spaceHeld = false;
    e.preventDefault();
  }
}

function launch() {
  new Dragster(document.body);
  overlay = document.getElementById('overlay');
  canvasOverlay = document.getElementById('can-overlay');
  spotlight = document.getElementById('spotlight');
  canvas = document.getElementById('canvas');
  ctx = canvas.getContext('2d');
  console.log('load');
  
  document.body.addEventListener('dragster:enter', dragEnter);
  document.body.addEventListener('dragover', dragOver);
  document.body.addEventListener('dragster:leave', dragLeave);
  document.body.addEventListener('drop', drop);
  
  addEventListener('keydown', keyDown);
  addEventListener('keyup', keyUp);
  
  canvas.addEventListener('click', click);
  
  state = 'I1';
}

window.addEventListener('load', launch, false);

</script>
</head>
<body>
<div id="overlay" ><h1>drop here!</h1></div>

<div id="meta">
<div id="candiv">
<div id="can-overlay">
<div id="spotlight"></div>
</div>
<canvas id="canvas" width=500 height=500></canvas>
</div>
<div id="textdiv">
<h2>Instructions</h2>
remember you are mechanical, not only in the ball and socket of your shoulders, or the resilient padding of your knees, but are in fact built from hinges, gears, and switches all the way into to your smallest bits

</ol>
</div>

</div>

</body>
</html>