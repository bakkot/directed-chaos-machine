<html>
<head>
<style>
#overlay {
background: none repeat scroll 0 0 #424242;
height: 100%;
width: 100%;
position: fixed;
top: 0;
left: 0;
opacity: .8;
pointer-events: none;
}
</style>


<script src="numeric-1.2.6.js"></script> <!-- only used for solving a system of linear equations, 'cause I'm lazy --> 
<script src="dragster.js"></script> <!-- for dragging files to work as expected. also, wtf, this should not be necessary. --> 
<script>
var overlay, canvas, ctx, imgScale, state, spaceHeld;
var inPoints = [];
var outPoints = [];
var transforms = [];
var MAXWIDTH = 500;

function relCoords(event, ele){
  var rect = ele.getBoundingClientRect();
  return {x: event.clientX - rect.left, y: event.clientY - rect.top};
}

function affineFactory(a, b, c, d, e, f) {
  return function(p) {
    return {x: a*p.x + b*p.y + e, y: c*p.x + d*p.y + f};
  }
}


/* logic:
Ax'   a b   Ax      e
Ay' = c d   Ay    + f


Ax' = aAx + bAy + e
Ay' = cAx + dAy + f

first computation solves for a, b, e, second for c, d, f.
*/
function makeTransform(inPoints, outPoints) {
  var A = [ [inPoints[0].x, inPoints[0].y, 1],
            [inPoints[1].x, inPoints[1].y, 1],
            [inPoints[2].x, inPoints[2].y, 1] ];
  var B1 = [ outPoints[0].x, outPoints[1].x, outPoints[2].x ];
  var B2 = [ outPoints[0].y, outPoints[1].y, outPoints[2].y ];
  
  var X1 = numeric.solve(A, B1);
  var X2 = numeric.solve(A, B2);
  
  return affineFactory(X1[0], X1[1], X2[0], X2[1], X1[2], X2[2]);
}

function transform(p) {
  var ind = Math.floor(Math.random() * transforms.length);
  return transforms[ind](p);
}





function drawPoint(p) {
  ctx.fillRect(p.x, p.y, 1, 1);
}

function drawIFS() {
  for(var i=0; i<1000; ++i) {
    var p = {x: Math.random() * canvas.width, y: Math.random() * canvas.height};
    for(var j=0; j<1000; ++j) {
      p = transform(p);
    }
    for(var j=0; j<1000; ++j) {
      var ind = Math.floor(Math.random() * transforms.length);
      p = transforms[ind](p);
      drawPoint(p);
    }
  }
}


var count = 0;
var SPEED = 20;
var RESETEVERY = 3000;
var SKIP = 100;
var DELAY = 1;
var point;
function draw() {
  count += SPEED;
  if(typeof point == 'undefined' || count == RESETEVERY) {
    point = {x: Math.random() * canvas.width, y: Math.random() * canvas.height};
    for(var i=0; i<SKIP; ++i) {
      var ind = Math.floor(Math.random() * transforms.length);
      point = transform(point);
    }
  }
  
  for(var i=0; i<SPEED; ++i) {
    point = transform(point);
    drawPoint(point);
  }
  
  if(!spaceHeld) return;
  
  setTimeout(draw, DELAY);
}







function dragEnter(e) {
  e.stopPropagation();
  e.preventDefault();
  console.log('enter');
  
  overlay.style.display = 'block';
}

function dragOver(e) {
  e.stopPropagation();
  e.preventDefault();
  //console.log('over')
}

function dragLeave(e) {
  console.log('leave')
  overlay.style.display = 'none';
}

function drop(e) {
  e.stopPropagation();
  e.preventDefault();
  console.log('drop')
  overlay.style.display = 'none';
  
  processFiles(e.dataTransfer.files);
}


function processFiles(files) {
  if(files.length != 1) { // todo errors
    return;
  }
  if (!files[0].type.match(/image.*/)) { // todo errors
    return;
  }

  // thanks http://stackoverflow.com/a/10209693/1644272
  // https://developer.mozilla.org/en-US/docs/Using_files_from_web_applications#Selecting_files_using_drag_and_drop
  var img = new Image();
  var src = URL.createObjectURL(files[0]);
  img.src = src;
  img.onload = function(){
    console.log(img.height);
    //var imgWidth = Math.min(img.width, MAXWIDTH);
    imgScale = Math.min(img.width, MAXWIDTH) / img.width;
    canvas.width = img.width * imgScale;
    canvas.height = img.height * imgScale;
    ctx.globalAlpha = 0.2;
    ctx.drawImage(img, 0, 0, img.width * imgScale, img.height * imgScale);
    ctx.globalAlpha = 1;
    URL.revokeObjectURL(src);
  }
  //console.log(files[0])
}



function click(e) {
  var p = relCoords(e, canvas);
  ctx.beginPath();
  ctx.arc(p.x,p.y,3,0,2*Math.PI);
  ctx.stroke();
  advance(p);
}

function advance(p) {
  switch (state) {
    case 'I1':
      inPoints[0] = p;
      state = 'I2';
      break;
    case 'I2':
      inPoints[1] = p;
      state = 'I3';
      break;
    case 'I3':
      inPoints[2] = p;
      state = 'O1';
      break;
    case 'O1':
      outPoints[0] = p;
      state = 'O2';
      break;
    case 'O2':
      outPoints[1] = p;
      state = 'O3';
      break;
    case 'O3':
      outPoints[2] = p;
      transforms.push(makeTransform(inPoints, outPoints));
      outPoints = [];
      state = 'O1';
      break;
    case 'Done':
      break;
    default: 
      alert('wat');
  }
}

function keyDown(e) {
  switch (e.which) {
    case 32: // space
      spaceHeld = true;
      e.preventDefault();
      draw();
      break;
    case 8: // backspace
      e.preventDefault();
      break;
  }
}

function keyUp(e) {
  if (e.which == 32) {
    spaceHeld = false;
    e.preventDefault();
  }
}

function inputDone() {
  state = 'Done';
  drawIFS();
}

function launch() {
  new Dragster(document.body);
  overlay = document.getElementById('overlay');
  canvas = document.getElementById('canvas');
  ctx = canvas.getContext('2d');
  console.log('load');
  
  document.body.addEventListener('dragster:enter', dragEnter);
  document.body.addEventListener('dragover', dragOver);
  document.body.addEventListener('dragster:leave', dragLeave);
  document.body.addEventListener('drop', drop);
  
  addEventListener('keydown', keyDown);
  addEventListener('keyup', keyUp);
  
  canvas.addEventListener('click', click);
  
  state = 'I1';
}

window.addEventListener('load', launch, false);

</script>
</head>
<body>
<div id="overlay" style="display: none"><h1>drop here!</h1></div>
<canvas id="canvas" width=500 height=500></canvas>
</body>
</html>